<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://notes-tukki.dotcloud.com/feed.atom</id>
  <updated>2011-12-17T00:00:00Z</updated>
  <link href="http://notes-tukki.dotcloud.com" />
  <link href="http://notes-tukki.dotcloud.com/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://notes-tukki.dotcloud.com/feed.atom">
    <title type="text">Hierarchecal Data on Database</title>
    <id>http://notes-tukki.dotcloud.com/2011/12/02/hierarchical-data-on-database</id>
    <updated>2011-12-02T00:00:00Z</updated>
    <link href="http://notes-tukki.dotcloud.com/2011/12/02/hierarchical-data-on-database" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a class="reference external" href="http://imrannazar.com/Modified-Preorder-Tree-Traversal"&gt;MPTT&lt;/a&gt;, modified pre-order tree trasversal&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Materialized_path"&gt;Materialized Path&lt;/a&gt;, a technique for encoding a tree in a flat data structure.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/django-mptt/django-mptt/"&gt;django-mptt&lt;/a&gt;, MPTT for Django&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://sqlamp.angri.ru/"&gt;sqlamp&lt;/a&gt;, Materialized Path for SQLAlchemy.&lt;/p&gt;
&lt;p&gt;对于带等级的数据如果写入频繁, 考虑把排序这部分独立? 例如在内存上面独立一段时间, 或者Flat List蛮快的. 读写同步这部分&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.sitepoint.com/hierarchical-data-database/"&gt;Storing Hierarchical Data in a Database Article&lt;/a&gt;, 用PHP的解析了MPTT的实现&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://evolt.org/node/4047/"&gt;Four ways to work with hierarchical data&lt;/a&gt;, 列出了Recursion, Stack, Flat Table, MPTT四种方法上面的好坏.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.slideshare.net/billkarwin/models-for-hierarchical-data"&gt;Models for Hierarchichical Data with SQL and PHP&lt;/a&gt;, 图文并茂. 69页显示了一个表格 &amp;quot;Choosing the Right Design&amp;quot;. Closure Table除了多一个表外, 所有的情况都是Easy.&lt;/p&gt;
&lt;p&gt;对于Closure Table, &amp;quot;A node even connects to itself&amp;quot;, Why? 用来确定自己的身份, 确定自己是根节点? 在 &lt;a class="reference external" href="http://karwin.blogspot.com/2010/03/rendering-trees-with-closure-tables.html"&gt;Karwin&lt;/a&gt; 的blog评论中做了解析, 根结点只是一点:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
I have at least three reasons why the self-referencing nodes are useful.

1. Primary key columns must be non-nullable, and the two columns of ancestor,
   descendant in the closure table serve as the best primary key.

2. The self-referencing row makes it easier when you add a new child node.
   For example, if you have a path A-B-C-D and you want to add a new child of D,
   you just run:

      SELECT ancestor, E FROM closure WHERE descendant = D

   If you didn't have a self-referencing row (D,D),
   you'd have to add the last path (D,E) by hand anyway.

3. Most of the time when you want to query either a chain of ancestors of D,
   you'd want to include D in the result too. E.g. a breadcrumbs query.
   If you didn't have the self-referencing row, you'd get the ancestors of D,
   but not D itself, from this query:

        SELECT ancestor FROM closure WHERE descendant = D

    With the self-referencing row, you get ancestors and also D itself.
    You get a similar benefit when you want to query for a subtree
    and include the top node of that subtree.

         SELECT descendant FROM closure WHERE ancestor = B

    So yes, I do think the self-referencing row gives several benefits,
    even though it looks superfluous at first.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/4048151/what-are-the-options-for-storing-hierarchical-data-in-a-relational-database"&gt;What are the Options for Storing Hierarchical Data in a Relational Database?&lt;/a&gt;, 提问者理出了好多选择. 提问艺术的高手.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://troels.arvin.dk/db/rdbms/links/#hierarchical"&gt;Hierarchical data in RDBMSs&lt;/a&gt;, 很全面的数据收集整理&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.postgresql.org/docs/current/static/ltree.html"&gt;Postgresql ltree&lt;/a&gt;, This module implements a data type ltree for representing labels of data stored in a hierarchical tree-like structure.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Fri Dec  2 16:59:20 CST 2011 --&amp;gt;&lt;/p&gt;
&lt;p&gt;[update] 简单的对比记录&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;经常读写但不在意查询子树结构的, 用Adjacency List(邻接列表). 递归查询&lt;/li&gt;
&lt;li&gt;不经常改写, 且需要经常查子树结构, 用nested sets&lt;/li&gt;
&lt;li&gt;Path Enumeration查询直接子节点比较麻烦. 对生成路径有天然的优势.
树结构排序也需要额外的字段协调&lt;/li&gt;
&lt;li&gt;Closure Table -&amp;gt; 两个表. 查询子孙很容易. 但构建目录结构需要一次&amp;quot;group by&amp;quot;
在非按ID顺序情况下构建树缺乏优势.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有银弹. Adjacency List是基础模型, 然后可以按需求选择对应的方法/变种进行辅助. &lt;a class="reference external" href="https://github.com/django-mptt/django-mptt/"&gt;django-mptt&lt;/a&gt; 实现中, 除了lft/ rght外, 保存对应的父节点, 还引入tree_id, level两个字段来辅助查询/构建树结构.&lt;/p&gt;
&lt;p&gt;再来, 还有NoSQL组合使用的可能.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Mon Dec 19 15:22:43 CST 2011 --&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://notes-tukki.dotcloud.com/feed.atom">
    <title type="text">MySQL group_concat on PostgreSQL</title>
    <id>http://notes-tukki.dotcloud.com/2011/12/03/mysql-group-concat-on-postgresql</id>
    <updated>2011-12-03T00:00:00Z</updated>
    <link href="http://notes-tukki.dotcloud.com/2011/12/03/mysql-group-concat-on-postgresql" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;源于 &lt;a class="reference external" href="http://karwin.blogspot.com/2010/03/rendering-trees-with-closure-tables.html"&gt;Rendering Trees with Closure Tables&lt;/a&gt; 例子是基于MySQL的, 列出Path用的 &lt;a class="reference external" href="http://dev.mysql.com/doc/refman/5.1/en/group-by-functions.html#function_group-concat"&gt;GROUP_CONCAT()&lt;/a&gt; 在Postgresql上面没有对应的直接实现. 下面是自己对应Category版本的解决方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;array_to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array_agg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;-- line_2&lt;/span&gt;
&lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;category&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;
&lt;span class="k"&gt;group&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;
&lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;-- line_last&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是PostgreSQL-9.0以上版本的, 可以用 &lt;a class="reference external" href="http://developer.postgresql.org/pgdocs/postgres/functions-aggregate.html"&gt;string_agg&lt;/a&gt; 代替上面的array_to_string:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
string_agg(cat.label, '/' order by cat.id) -- line_2
&lt;/pre&gt;
&lt;p&gt;其中, 如果line_2里面不用 &amp;quot;order by cat.id&amp;quot;, 得到的路径是倒序的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;sub11/sub1/root&amp;quot;
&lt;/pre&gt;
&lt;p&gt;如果没有line_last的&amp;quot;order by path&amp;quot;, 得到的结果是按&amp;quot;descendant&amp;quot;升序的, 没有把目录树结构顺序表现出来:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;root/sub1&amp;quot;
&amp;quot;root/sub2&amp;quot;
&amp;quot;root/sub1/sub11&amp;quot;
&amp;quot;root/sub2/sub21&amp;quot;
&amp;quot;root/sub2/sub21/sub211&amp;quot;
&lt;/pre&gt;
&lt;p&gt;因为还没有实现文中提到的lenght, 所以也是假定祖先目录的id值比子孙目录的id值小.&lt;/p&gt;
&lt;p&gt;列出在Google找到的有用信息.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.pgsql.cz/index.php/PostgreSQL_SQL_Tricks#MySQL_function_group_concat_in_PostgreSQL"&gt;MySQL function group_concat in PostgreSQL&lt;/a&gt;, 里面提到个&amp;quot;workaround&amp;quot;(应急方案?). 用&amp;quot;array_to_string + array_agg&amp;quot;组合处理.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wiki.postgresql.org/wiki/Array_agg"&gt;array age on postgresql wiki&lt;/a&gt;, 说明了在8.4版本前的PostgreSQL该怎样去实现这个 &lt;em&gt;array_agg&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.postgresonline.com/journal/archives/191-stringagg.html"&gt;STRING AGGREGATION IN POSTGRESQL, SQL SERVER, AND MYSQL&lt;/a&gt;, 详细的对比式实现&lt;/p&gt;
&lt;p&gt;中文世界没详细找, 这里有一个 &lt;a class="reference external" href="http://hi.baidu.com/bsdgo/blog/item/7a79fd02359ef71f1c9583f0.html"&gt;postgresql如何实现group_concat功能&lt;/a&gt;, 但相对来说, 信息量还不够.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Sat Dec  3 21:05:25 CST 2011 --&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://notes-tukki.dotcloud.com/feed.atom">
    <title type="text">Rendering SubTrees with Closure Tables</title>
    <id>http://notes-tukki.dotcloud.com/2011/12/17/rendering-subtree-with-closure-tables</id>
    <updated>2011-12-17T00:00:00Z</updated>
    <link href="http://notes-tukki.dotcloud.com/2011/12/17/rendering-subtree-with-closure-tables" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;First of all, thanks Bill Karwin, for all his different posts and articles on Closure Tables, and his great book &lt;a class="reference external" href="http://pragprog.com/book/bksqla/sql-antipatterns"&gt;SQL Antipatterns&lt;/a&gt; (I read the Chinese version)&lt;/p&gt;
&lt;p&gt;this note base on Bill Karwin's &lt;a class="reference external" href="http://karwin.blogspot.com/2010/03/rendering-trees-with-closure-tables.html"&gt;Rendering Trees with Closure Tables&lt;/a&gt;, the page is great, and telling us how to render trees with closure tables. part from this page:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nf"&gt;group_concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="k"&gt;separator&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; -&amp;gt; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;
&lt;span class="k"&gt;group&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Got:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------------------------+
| path                                            |
+-------------------------------------------------+
| rootree -&amp;gt; 1stbranch                            |
| rootree -&amp;gt; midbranch                            |
| rootree -&amp;gt; midbranch -&amp;gt; corebranch              |
| rootree -&amp;gt; midbranch -&amp;gt; corebranch -&amp;gt; leafnodes |
| rootree -&amp;gt; lastbranch                           |
| rootree -&amp;gt; lastbranch -&amp;gt; lastleaf               |
+-------------------------------------------------+
&lt;/pre&gt;
&lt;p&gt;but, how about when I just want to render the subtree? I need the tree show of the &amp;quot;midbrance&amp;quot;, I change the query to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nf"&gt;group_concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="k"&gt;separator&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; -&amp;gt; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="c1"&gt;-- and d.descendant != d.ancestor&lt;/span&gt;
&lt;span class="k"&gt;group&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I got:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------------------------+
| path                                            |
+-------------------------------------------------+
| rootree -&amp;gt; midbranch                            |
| rootree -&amp;gt; midbranch -&amp;gt; corebranch              |
| rootree -&amp;gt; midbranch -&amp;gt; corebranch -&amp;gt; leafnodes |
+-------------------------------------------------+
&lt;/pre&gt;
&lt;p&gt;I don't care about the &lt;em&gt;roottree&lt;/em&gt; any bit. I want the output like this, just the tree view of the &lt;em&gt;midbranch&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+----------------------------------+
| path                             |
+----------------------------------+
| midbranch                        |
| midbranch-&amp;gt;corebranch            |
| midbranch-&amp;gt;corebranch-&amp;gt;leafnodes |
+----------------------------------+
&lt;/pre&gt;
&lt;p&gt;I'm just a sql newbie, and find out a solution like this finally:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nf"&gt;group_concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="k"&gt;separator&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;left&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="k"&gt;group&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the point of the change is, &lt;em&gt;just fire the group operate on the subset&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;-- get the subset closure table of node.id == 3&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;left&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This sulotion also work on the &lt;em&gt;roottree&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I don't know the performance about this change. From pgAdmin3 explain -- I had a PostgreSQL version of closure tables and first found out this problem and sulotion on it -- two version share the save query plan, but the later get less row in the &lt;em&gt;Hast Join&lt;/em&gt; (the subset).&lt;/p&gt;
&lt;p&gt;I can't prove it absolute right, but it work so far so good. I even thought how to use &amp;quot;closure table + path enumeration&amp;quot; to solve this problem at first. Maybe this was not a problem, but I'm just scratch my own itch.&lt;/p&gt;
&lt;p&gt;Here is my PostgreSQL version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;string_agg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;closures&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="k"&gt;left&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;closures&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ancestor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="k"&gt;group&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;descendant&lt;/span&gt;
&lt;span class="k"&gt;order&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;!-- Sat Dec 17 00:28:32 CST 2011 --&amp;gt;&lt;/p&gt;
</content>
  </entry>
</feed>

