<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://tukki.github.io/develop-notes/feed.atom</id>
  <updated>2012-05-06T00:00:00Z</updated>
  <link href="http://tukki.github.io/develop-notes/" />
  <link href="http://tukki.github.io/develop-notes/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">hosting static website on gae</title>
    <id>http://tukki.github.io/develop-notes/2011/11/30/hosting-static-website-on-gae</id>
    <updated>2011-11-30T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2011/11/30/hosting-static-website-on-gae" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;起因: 突然想把部署在DotCloud上面的notes迁移到GAE上面. 理由很简单, 冲动.&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;获得:&lt;/dt&gt;
&lt;dd&gt;发现GAE新版支持Jinja2
&lt;a class="reference external" href="http://code.google.com/appengine/docs/python/config/appconfig.html"&gt;Application　Configuration&lt;/a&gt; 比想象中强大.
GAE不支持中文文件名上传.
fork了rstblog进行url生成的修改&lt;/dd&gt;
&lt;dt&gt;失去:&lt;/dt&gt;
&lt;dd&gt;6+4 小时. 主要时间放在了URL后面的 &lt;em&gt;trailing slash&lt;/em&gt; 上面&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="static-files-on-gae"&gt;
&lt;h2&gt;Static Files on GAE&lt;/h2&gt;
&lt;p&gt;首先是 &lt;a class="reference external" href="http://code.google.com/appengine/docs/python/config/appconfig.html#Static_File_Handlers"&gt;官方文档&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Static file handlers can be defined in two ways:
  as a directory sturcture of static files that maps to a URL path,
  or as a pattern that maps URLs to specific files.
&lt;/pre&gt;
&lt;p&gt;rstblog生成的静态文件结构:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
2011
  |-- 10
  |   |-- 04
  |   |   |-- first-rstblog-post
  |   |   |   `-- index.html
  |   |   `-- make-rstblog-support-chinese-filename
  |   |   |    `-- index.html
  |   |    `-- index.html
  |   `-- index.html
&lt;/pre&gt;
&lt;p&gt;用 &lt;a class="reference external" href="http://code.google.com/appengine/docs/python/config/appconfig.html#Static_Directory_Handlers"&gt;Static Directory Handlers&lt;/a&gt; 映射这个目录结构. 因为全部都是静态文件, 所以URL就不用前序了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- url: /
  static_dir: rstblog
&lt;/pre&gt;
&lt;p&gt;只是这样的话, 只能用完整路径来显示对应的文件. 而当访问一个目录时, 例如 &amp;quot;/2011/11/28/about-the-hacker-news-ranking/&amp;quot;, 实际要显示的是其目录下的&amp;quot;index.html&amp;quot;文件. (rstblog生成的目录都有对应一个&amp;quot;index.html&amp;quot;来显示了该目录下的文件). 这时要用到的是 &lt;a class="reference external" href="http://code.google.com/appengine/docs/python/config/appconfig.html#Static_File_Pattern_Handlers"&gt;Static File Pattern Handlers&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- url: (.*)/
  static_files: rstblog\1/index.html
      upload: rstblog\1/index.html
&lt;/pre&gt;
&lt;p&gt;正则式用的是 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Regular_expression%23Syntax&amp;amp;usg=__mBDvPGMNbDvCnmh1oLFnVOCuNwI="&gt;POSIX extended regular expression syntax&lt;/a&gt;. &amp;quot;以0个或者0个以上的字符&amp;quot;外加&amp;quot;/&amp;quot;结尾的URL, 都认为是目录, 输出其目录下的&amp;quot;index.html&amp;quot;文件内容.&lt;/p&gt;
&lt;p&gt;看文档和相关的blog时看上去很简单. 问题却发生在实际执行中. -_-!!&lt;/p&gt;
&lt;p&gt;rstblog对于记录的链接生成是不带&amp;quot;/&amp;quot;结尾的. 在DotCloud或者自带的开发服务器上面一直没注意到, 因为都自动加&amp;quot;/&amp;quot;后进行了redirect. 而GAE本来就不是为了部署静态文件用的, 所以不会自动识别并自动重定向. (应该这样理解?). Django也是靠在settings上面制定才会主动帮忙加.&lt;/p&gt;
&lt;p&gt;一开始再GAE方面没找到合适的方法, 就去改rstblog的代码. 让生成的链接自动追加&amp;quot;/&amp;quot;.&lt;/p&gt;
&lt;p&gt;在github上面fork了rstblog进行修改. &lt;a class="reference external" href="https://github.com/Tukki/rstblog"&gt;Here&lt;/a&gt;. 其实只是改了其Builder初始化时注册的&amp;quot;page'格式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#self.register_url(&amp;#39;page&amp;#39;, &amp;#39;/&amp;lt;path:slug&amp;gt;&amp;#39;)&lt;/span&gt;
&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;register_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;page&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/&amp;lt;path:slug&amp;gt;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6小时结束.&lt;/p&gt;
&lt;p&gt;后面四小时属于不满意上面的解决方案. 尝试写个Redirector追加&amp;quot;/&amp;quot;到URL上面.&lt;/p&gt;
&lt;p&gt;一直没有理清思路, 也忽略了GAE的handlers配置是带先后顺序的, 匹配后就不再往下尝试. 于是发生了痛苦的事情.&lt;/p&gt;
&lt;p&gt;问题在于如何匹配不是指向最终文件的URL, 然后执行script追加&amp;quot;/&amp;quot;.&lt;/p&gt;
&lt;p&gt;找到的示例都是带前序的, 有明确的pattern. 当rstblog生成的目录结构不适合这样, 也不想重构这个目录结构. 一直在试错, 最后简单点, 确定规则: 只要URI上面不带&amp;quot;.&amp;quot;的, 都进行重定向:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- url: /([^\.]*)
  script: redirector.app
&lt;/pre&gt;
&lt;p&gt;用的是redirector用的是webapp2:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;webapp2&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RedirectorHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webapp2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RequestHandler&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
       &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
       &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;
       &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webapp2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WSGIApplication&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;(.*)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RedirectorHandler&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c"&gt;#直接匹配所有.&lt;/span&gt;
&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是app.yaml&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="l-Scalar-Plain"&gt;application&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;scarecrow-notes&lt;/span&gt;
&lt;span class="l-Scalar-Plain"&gt;version&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;1&lt;/span&gt;
&lt;span class="l-Scalar-Plain"&gt;runtime&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;python27&lt;/span&gt;
&lt;span class="l-Scalar-Plain"&gt;api_version&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;1&lt;/span&gt;
&lt;span class="l-Scalar-Plain"&gt;threadsafe&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;true&lt;/span&gt;

&lt;span class="l-Scalar-Plain"&gt;handlers&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt;

&lt;span class="p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;(.*)/&lt;/span&gt;
  &lt;span class="l-Scalar-Plain"&gt;static_files&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;rstblog\1/index.html&lt;/span&gt;
      &lt;span class="l-Scalar-Plain"&gt;upload&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;rstblog(.*)/index.html&lt;/span&gt;

&lt;span class="c1"&gt;#不带&amp;quot;.&amp;quot;的路径进入redirect状态&lt;/span&gt;
&lt;span class="p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;/([^\.]*)&lt;/span&gt;
  &lt;span class="l-Scalar-Plain"&gt;script&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;redirector.app&lt;/span&gt;

&lt;span class="p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;/&lt;/span&gt;
  &lt;span class="l-Scalar-Plain"&gt;static_dir&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l-Scalar-Plain"&gt;rstblog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;update一下, 可行. 写记录再花4小时... 真少不了折腾.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Wed Nov 30 23:59:51 CST 2011 --&amp;gt;&lt;/p&gt;
&lt;p&gt;Useful links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="http://www.instantfundas.com/2011/02/how-to-host-static-websites-on-google.html"&gt;How to Host Static Websites on Google App Engine for Free&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;里面提到的是windows环境下&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="http://blog.engelke.com/2008/07/30/google-appengine-for-web-hosting/"&gt;Google AppEngine for web hosting&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个只是没处理无&amp;quot;/&amp;quot;的情况&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://gist.github.com/873098"&gt;App.yaml designed for serving a static site on Google App Engine (Python).&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;超详细的配置文件... 指定了各种类型&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="http://blog.engelke.com/2008/07/31/appengine-rewrite-rules/"&gt;AppEngine “Rewrite Rules”&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;redirector的火花从这里爆发&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Notes for Middleware</title>
    <id>http://tukki.github.io/develop-notes/2012/04/03/notes-for-middleware</id>
    <updated>2012-04-03T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/04/03/notes-for-middleware" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;还没认真地去看PEP333, 只是记录&lt;/p&gt;
&lt;p&gt;以前用django的时候, 没有区分好其内置的 &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/topics/http/middleware"&gt;Django Middleware&lt;/a&gt; 和标准下的 &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0333/#id17"&gt;WSGI Middleware&lt;/a&gt;. 直到离开过Django, 才明白为什么叫 &amp;quot;Django lets you write web apps in Django&amp;quot;&lt;/p&gt;
&lt;p&gt;django把wsgi隐藏的太好了. 以致我曾认为wsgi就是django这样的. environ真的很少用到.&lt;/p&gt;
&lt;p&gt;现在看来, django的middleware是对wsgi的middleware在django层面的再封装, 提供django-like的实现方式: process_request, proces_response, etc. 模仿PJE的说法 &lt;a class="reference external" href="http://dirtsimple.org/2007/02/wsgi-middleware-considered-harmful.html"&gt;If your appkication requires that API to be present, then it's not middleware any more!&lt;/a&gt;, django的middleware更多时候, 是application的一部分, 其复用程度, 局限于django工程.&lt;/p&gt;
&lt;p&gt;这里匆忙找到的两篇博文, &lt;a class="reference external" href="http://www.evanfosmark.com/2008/12/python-wsgi-middleware-for-automatic-gzipping/"&gt;Python WSGI Middleware for automatic Gzipping&lt;/a&gt; 介绍了如何写WSGI标准的Middleware; &lt;a class="reference external" href="http://eflorenzano.com/blog/2008/11/17/wsgi-middlware-awesome-django-use-it-more/"&gt;WSGI Middleware is Awesome, and Django Should Use It More&lt;/a&gt;, 介绍1.4之前如何整合django和其他Middleware实现.&lt;/p&gt;
&lt;p&gt;对于WSGI, 在django的1.4出来后更好的支持, &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/releases/1.4/#improved-wsgi-support"&gt;Improved WSGI support&lt;/a&gt;, 或者, django要回归WSGI生态圈了, 事实上, 我不确认django是否离开过&lt;/p&gt;
&lt;p&gt;&amp;lt;Tue Apr  3 22:07:13 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Python Dict Sort</title>
    <id>http://tukki.github.io/develop-notes/2012/03/10/python-dict-sort</id>
    <updated>2012-03-10T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/03/10/python-dict-sort" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;div class="section" id="sort-a-dictionary-by-key-or-value"&gt;
&lt;h2&gt;Sort a dictionary by key or value&lt;/h2&gt;
&lt;p&gt;checkout &lt;a class="reference external" href="http://stackoverflow.com/questions/613183/python-sort-a-dictionary-by-value"&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面的例子如果改用lambda的话(不知道性能是否有很大的差别...)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;sorted_x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# by value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;联系昨晚遇到的场景, dict的value是列表. 按value长度排序一下. 我用了个笨方法, 再开一个列表记录value的长度与key的对应值, 再枚举输出. 其实可以更pythonic点:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sorted_x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里也额外记录一下, 在python里面list的比较, 是按对应位移比较的. 相等则下一位.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ordered-dict"&gt;
&lt;h2&gt;Ordered Dict&lt;/h2&gt;
&lt;p&gt;python的dict内部是无序的. 如果想要有序的dict?&lt;/p&gt;
&lt;p&gt;Python2.7的collections有 &lt;a class="reference external" href="http://docs.python.org/library/collections.html?highlight=ordereddict#collections.OrderedDict"&gt;OrderedDict&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;对于Python2.4-2.6, 有 &lt;a class="reference external" href="http://pypi.python.org/pypi/ordereddict"&gt;pypi ordereddict&lt;/a&gt;, &lt;em&gt;A drop-in substitute for Py2.7's new collections.OrderedDict&lt;/em&gt; .&lt;/p&gt;
&lt;p&gt;Django的比较有爱, 内置了一个SortedDict实现, 在utils.datastructures里面.&lt;/p&gt;
&lt;p&gt;简单看了看代码实现, Django的实现是&amp;quot;继承dict, 然后在内部维护一个key列表&amp;quot;. 而ordereddict的, 有一个 __map[key] = [link_prev, link_next, key]. 是直接链表维护, 减少key order的变动成本.&lt;/p&gt;
&lt;p&gt;原来某君说的用list来维护顺序低效的出处在这里. 受用了.&lt;/p&gt;
&lt;p&gt;&amp;lt;Sat Mar 10 18:14:54 CST 2012&amp;gt;&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Selenium使用记录</title>
    <id>http://tukki.github.io/develop-notes/2012/03/01/notes-for-selenium</id>
    <updated>2012-03-01T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/03/01/notes-for-selenium" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a class="reference external" href="http://seleniumhq.org/"&gt;SeleniumHQ&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Selenium aotumates browsers.
&lt;/pre&gt;
&lt;p&gt;提供了一个控制浏览器的大好方式, 开源免费可编程.&lt;/p&gt;
&lt;p&gt;自动化浏览器操作, 直接查看官方例子 &lt;a class="reference external" href="http://seleniumhq.org/docs/03_webdriver.html#getting-started-with-selenium-webdriver"&gt;Getting Started With Selenium-WebDriver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果要使用Chrome, &lt;a class="reference external" href="http://seleniumhq.org/docs/03_webdriver.html#chrome-driver"&gt;得要有chromedriver&lt;/a&gt;, &lt;a class="reference external" href="http://code.google.com/p/chromedriver/"&gt;chromedriver官方地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;selenium的WebDriver提供了直接保存screenshot的实现: save_screenshot和get_screenshot_as_file, 还有一个get_screenshot_as_base64:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Gets the screenshot of the current window as a base64 encoded string
which is useful in embedded images in HTML.
&lt;/pre&gt;
&lt;p&gt;单是使用selenium, 会看到浏览器控制的全过程. 如果想不被干扰, 可以用到 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Xvfb"&gt;xvfb&lt;/a&gt;. python点, 找到 &lt;a class="reference external" href="https://github.com/ponty/PyVirtualDisplay"&gt;PyVirtualDisplay&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyvirtualdisplay&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt;
&lt;span class="n"&gt;display&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;visible&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;768&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# .....&lt;/span&gt;
&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样, 就能无声无色地控制浏览器了.&lt;/p&gt;
&lt;p&gt;拓展开来, selenium可以解决的问题: 1) ajax页面自动登录; 2) 动态页面内容获取; 3) 网站截图&lt;/p&gt;
&lt;p&gt;不知道哪些提供网站缩略图的实现, 用的是怎样的技术?&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">using IPython magic-save</title>
    <id>http://tukki.github.io/develop-notes/2012/05/06/ipython-magic-save</id>
    <updated>2012-05-06T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/05/06/ipython-magic-save" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;利用ipython证明一段交互逻辑后, 想保存记录. 在stackoverflow找到 &lt;a class="reference external" href="http://stackoverflow.com/questions/947810/how-to-save-a-python-interactive-session"&gt;How to save a Python interactive session?&lt;/a&gt;, 然后知道IPython的 &lt;a class="reference external" href="http://ipython.org/ipython-doc/stable/api/generated/IPython.core.interactiveshell.html?highlight=save#IPython.core.interactiveshell.InteractiveShell.magic_save"&gt;magic-save&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Save a set of lines or a macro to a given filename.
Usage:
  %save [options] filename n1-n2 n3-n4 ... n5 .. n6 ...
&lt;/pre&gt;
&lt;p&gt;轻松保存记录到指定文件, 然后, 稍作编辑. 一个脚本大致成型.&lt;/p&gt;
&lt;p&gt;&amp;lt;Sun May  6 01:55:05 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Using SQLAlchemy in Django</title>
    <id>http://tukki.github.io/develop-notes/2012/04/28/using-sqlalchemy-in-django</id>
    <updated>2012-04-28T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/04/28/using-sqlalchemy-in-django" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;现在的工程还是基于Django, 不过ORM部分已经确认用SQLAlchemy了. 现在也建了一层DAL来管理数据非业务相关的实现, 看接口定义, 有点像让粒度小一点. 提供复用&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UserDAL.get_user_by_id(id)
ActionDAL.action(user_id, value)
&lt;/pre&gt;
&lt;p&gt;首先有个想法, 想让Session在request-response周期内自动管理transcations, 自然得动用Middleware. 有点懒, 直接上代码(未完整测试).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.utils.functional&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SimpleLazyObject&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;somewhere&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_dbSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;_cached_dbSession&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_cached_dbSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="c"&gt;#http://docs.sqlalchemy.org/en/latest/orm/session.html#committing&lt;/span&gt;
        &lt;span class="c"&gt;#In autocommit mode, a transaction can be initiated by calling the begin() method.&lt;/span&gt;
        &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_cached_dbSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_cached_dbSession&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;has_dbSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;_cached_dbSession&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SQLAlchemySessionMiddleware&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dbSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SimpleLazyObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;get_dbSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;has_dbSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;dbSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dbSession&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dbSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dbSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process_exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;has_dbSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
           &lt;span class="n"&gt;dbSession&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dbSession&lt;/span&gt;
           &lt;span class="n"&gt;dbSession&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用了SimpleLazyObject来管理request.dbSession是考虑到并非每个request都会用到dbSession, 就直接懒惰处理.&lt;/p&gt;
&lt;p&gt;像是解决问题了.&lt;/p&gt;
&lt;p&gt;两个困惑. 1)是不是需要用request.dbSession初始化DAL/参数传入; 2)如果不传值, 如何做到DALs上面能共用一个Session上下文.&lt;/p&gt;
&lt;p&gt;记得以前用Pyramid的时候也有遇到这个情况. 只是没总结好. 今晚回来好好查了下SQLAlchemy的文档, 找到似曾相似的 &lt;a class="reference external" href="http://docs.sqlalchemy.org/en/latest/orm/session.html#contextual-thread-local-sessions"&gt;Contextual/Thread-local Sessions&lt;/a&gt;, 使用scoped_session:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
By default, this context is the current thread.
&lt;/pre&gt;
&lt;p&gt;查查已有实现, 才发现现在定义的Session只是sessionmaker()出来. 改用scoped_session, 上面两个疑惑一并解决了吧.&lt;/p&gt;
&lt;p&gt;如果不是dbSession.begin(). 应该会忽略以下一个问题: 这个Middleware是否导致Session的Transaction太长了? 而且transaction的使用也不灵活. 再者, scoped_session的使用, 已经可以让整个Middleware实现无用化, 用错方法来解决问题了.&lt;/p&gt;
&lt;p&gt;现在想, 或在一个view级别的decorators足够了, django.db.transaction.commit_on_success. 再者, 过度设计了. 现在的系统需要用到transaction了吗?&lt;/p&gt;
&lt;p&gt;&amp;lt;Sat Apr 28 02:07:45 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Why I leave Pyramid</title>
    <id>http://tukki.github.io/develop-notes/2012/04/03/why-I-leave-pyramid</id>
    <updated>2012-04-03T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/04/03/why-I-leave-pyramid" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.pylonsproject.org/"&gt;Pyramid&lt;/a&gt;, Pylons和Repoze.bfg两个框架的合并产物. 2011年下半年用来做个两个最后失败只有上线没有运营的工程. 现在, 已经确认未来有一段时间不会再用其来构建python web project. 离开, 纯属个人喜欢, 非基于技术性的选择.&lt;/p&gt;
&lt;p&gt;一开始, 只是在享受django带来方便的同时, 不适应其居多的限制. 作为一个爱折腾喜欢灵活的人, 开始尝试 pylons + sqlalchemy. 却又适逢Pylons停止开发, 和Repoze.bfg衍生出Pyramid, 出于技术框架的在开源社区上面的支持程度来作长远的考虑 -- 回想这一点, 觉得有点不妥, startup的时候, 长远考虑不一定是件好事, 未来变化太多了, startup或者应该用熟悉的工具尽快起步 -- 于是改用了Pyramid.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Web development with style, your way!
&lt;/pre&gt;
&lt;p&gt;这句吸引了我. 但事实上, 自己对 web development 还没有自己的style. 不过, 里面一个单文件就搭建好一个简单的application, 至少当时对于只用过django的我是很吸引的. 当然django也可以做到, 其他框架也至此(web.py, flask). 借口! 灵活性吸引了我.&lt;/p&gt;
&lt;p&gt;django外面的世界, Template上面mako, jinja2都比django内置的强大(个人认为) form也更多的选择, django的orm在非django环境下面使用有点麻烦. 这些, 在Pylons/Pyramid上面都能自主选择.&lt;/p&gt;
&lt;p&gt;也许是太灵活, 而且我还是个版本控, 导致还没有style的我在选择上面走了不少弯路.&lt;/p&gt;
&lt;p&gt;1.0/1.1版的文档没有1.3版的清晰, 主推过Traversal, 事实上更多人习惯的是Route.&lt;/p&gt;
&lt;p&gt;内置的时Chameleon Template, 要用Mako还需要额外配置一下.&lt;/p&gt;
&lt;p&gt;内置的Authorization Policy, 感觉还不如用repoze.who/repoze.what. 一直就想不明白, 作为一个&amp;quot;灵活的框架&amp;quot;, 要内置的Authorization Policy干啥, 想原Pylons那样, 指导用可选的第三方实现不是一样可以吗?&lt;/p&gt;
&lt;p&gt;现在第三方依赖和第三方可选是两回事. Pyramid一开始时第三方依赖严重, 导致版本升级协调难. 在WebOb和Paste上面就载过跟斗. 后来Pyramid把Paste也舍弃了, 直接内置了相关的实现,(应该没记错). 也不知道算不算是间好事.&lt;/p&gt;
&lt;p&gt;可能, 当时最不习惯的, 莫过于interfaces了. 是Python不是Java吧.&lt;/p&gt;
&lt;p&gt;其实, 更多还是个人原因, 用一样的东西就喜欢全局地看其功能, 去了解其底层的实现. 而且自己还不是一个在深入研究python web framework的人. 所以, pyramid的灵活性, 不是我现在要去handle的. 灵活又小的框架, 现在有个想法, I will get &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; a try.&lt;/p&gt;
&lt;p&gt;不想掉入什么语言之争, 框架之争. 用合适的工具来解决问题. sorry, Pyramid. 在索取阶段已经选择离开, 还没作建设性的回馈. 有机会, 再合作.&lt;/p&gt;
&lt;p&gt;balabala又一个小时, 回看, 实在没什么建设性的内容. 总结能力要继续提高才行.&lt;/p&gt;
&lt;p&gt;&amp;lt;Tue Apr  3 16:38:33 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">使rstblog支持中文名的rst文件</title>
    <id>http://tukki.github.io/develop-notes/2011/10/04/make-rstblog-support-chinese-filename</id>
    <updated>2011-10-04T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2011/10/04/make-rstblog-support-chinese-filename" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;本人使用的系统环境, Fedora 14, LANG设定en_us.UTF-8. 安装的是 &lt;a class="reference external" href="https://github.com/mitsuhiko/rstblog"&gt;github&lt;/a&gt;
上rstblog的最新版本(commit 90ca1426a2). 如果以中文作为rst文件名(像本文), 在build时会抛出异常:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
File &amp;quot;/home/lazy/.virtualenvs/rstblog/lib/python2.7/site-packages
/Werkzeug-0.8.1-py2.7.egg/werkzeug/contrib/atom.py&amp;quot;, line 309, in generate
yield u'  &amp;lt;id&amp;gt;%s&amp;lt;/id&amp;gt;\n' % escape(self.id)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 33:
 ordinal not in range(128)
make: *** [build] Error 1
&lt;/pre&gt;
&lt;p&gt;根据trace信息可以知道时Werkzeug在生成Atom时抛的错误. 查看源码, 可以知道entry时Werkzeug.atom.FeedEntry的实例, 其在初始化的时候, 如果没找到id值, 就使用url作为id值. 而rstblog是使用slug作为其url的. 这样一来, 找到修改可能了&lt;/p&gt;
&lt;p&gt;找到rstblog.builder.Context. 文档说是&amp;quot;Per rendering information&amp;quot;, 初始化就带了source_filename. 估计修改这里比较安全(未对rstblog的源码通读). &lt;strong&gt;注意下面的修改方式只能证明在我的Fedoar下能行, 不确保是否完全正确, 或在其他平台也能用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改方式为把source_filename再decode一次. 因为是系统上的文件, 所以可以用sys.getfilesystemencoding()获取编码方式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#place in builder.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;default_encode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getfilesystemencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;#in Context.__init__()&lt;/span&gt;
&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;source_filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source_filename&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default_encode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再run_rstblog build一次, 这次没有报错.在debug_serve下测试页成功显示. 至于生成的atom是否能正确使用, 需部署到外网后再做验证&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;edit:&lt;/dt&gt;
&lt;dd&gt;因为想部署到GAE, 而GAE不支持中文文件名, 也没确定是否有方法. so, 遵守游戏规则, 改回英文名
Wed Nov 30 02:05:03 CST 2011&lt;/dd&gt;
&lt;/dl&gt;
</content>
  </entry>
</feed>

