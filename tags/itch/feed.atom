<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>/develop-notes/feed.atom</id>
  <updated>2011-10-21T00:00:00Z</updated>
  <link href="/develop-notes/" />
  <link href="/develop-notes/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="/develop-notes/feed.atom">
    <title type="text">在新浪微博网页添加ReadItLater功能</title>
    <id>/develop-notes/2011/10/21/using-read-it-later-in-weibo-webpage</id>
    <updated>2011-10-21T00:00:00Z</updated>
    <link href="/develop-notes/2011/10/21/using-read-it-later-in-weibo-webpage" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;About &lt;a class="reference external" href="http://readitlaterlist.com/"&gt;Read it later&lt;/a&gt;, bookmarking service, one of the GTD tools.&lt;/p&gt;
&lt;p&gt;关于 &lt;a class="reference external" href="http://weibo.com"&gt;新浪微博&lt;/a&gt;, 呃, 的确是一个不错的获取资讯的平台, 获取各种各样的自己感兴趣的资讯.&lt;/p&gt;
&lt;p&gt;总有些Weibo想稍候再读的, 例如有些音乐, 有些链接.  &lt;span class="strike"&gt;现阶段利用 ReadItLater的Add Links方法,&lt;/span&gt; 自己做了个书签工具作简单的注入实现. 又因为懒得每次点击书签栏, 追加了FireFox Greasemonkey和Chrome Extensions实现, 源码放在了 &lt;a class="reference external" href="https://github.com/Tukki/codesnippet/tree/master/javascript/Weibo-RIL"&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;效果图:&lt;/p&gt;
&lt;img alt="/static/2011-10/read-weibo-later.png" src="/static/2011-10/read-weibo-later.png" /&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;使用方法&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;如果使用书签栏工具的话, 自己创建书签, 将 &lt;a class="reference external" href="https://raw.github.com/Tukki/codesnippet/master/javascript/Weibo-RIL/for_bookmark_tool.min.js"&gt;js文件&lt;/a&gt; 的内容复制一份作为书签的网址/位置保存.&lt;/li&gt;
&lt;li&gt;如果使用firefox, 可以在 &lt;a class="reference external" href="http://userscripts.org/scripts/show/116025"&gt;UserScript&lt;/a&gt; 安装, 不过先得有插件 &lt;a class="reference external" href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/"&gt;Greasemonkey&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;如何使用的是chrome, 可以直接下载 &lt;a class="reference external" href="https://github.com/Tukki/codesnippet/blob/master/javascript/Weibo-RIL/read-weibo-later.crx"&gt;chrome extension打包文件&lt;/a&gt; 安装. 不准备添加到Chrome Webstore.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下内容是开放时的一些笔记.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="read-it-later-button"&gt;
&lt;h2&gt;Read It Later button&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;官方介绍: &lt;a class="reference external" href="http://readitlaterlist.com/api/buttons/"&gt;http://readitlaterlist.com/api/buttons/&lt;/a&gt;&lt;/div&gt;
&lt;div class="line"&gt;其重点在其js实现上面. &lt;a class="reference external" href="http://readitlaterlist.com/button/multi_v1.js"&gt;http://readitlaterlist.com/button/multi_v1.js&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过插入&amp;lt;iframe&amp;gt;获取按钮, 没有用到ajax操作. 而先前尝试用jQuery的异步调用其提供的API, 返回结果的确是'200ok', 但确实错误返回, 一直没找出原因.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="detect-dom-changed"&gt;
&lt;h2&gt;detect dom changed&lt;/h2&gt;
&lt;p&gt;要在ajax追加新微博后再次执行自定义的追加函数, 可以用 &lt;a class="reference external" href="http://help.dottoro.com/ljmcxjla.php"&gt;DOMNodeInserted event&lt;/a&gt;, 自己的实现中用了简单的锁, 对于发生连续的事件时, 减少追加函数的执行次数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;hassetup&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;detect_changed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;cbFunc&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
     &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;DOMNodeInserted&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;hassetup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;setTimeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
               &lt;span class="nx"&gt;cbFunc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
               &lt;span class="nx"&gt;hassetup&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
           &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
           &lt;span class="nx"&gt;hassetup&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
     &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="greasemonkey-notes"&gt;
&lt;h2&gt;Greasemonkey notes&lt;/h2&gt;
&lt;p&gt;在Greasemonkey中使用jQuery, 可以使用其 &lt;a class="reference external" href="http://wiki.greasespot.net/Metadata_Block#.40require"&gt;&amp;#64;require&lt;/a&gt;, &lt;a class="reference external" href="http://wiki.greasespot.net/Third-Party_Libraries"&gt;wiki&lt;/a&gt; 里面有介绍. 或在参看 &lt;a class="reference external" href="http://joanpiedra.com/jquery/greasemonkey/"&gt;这里&lt;/a&gt; 的实现, 用unsafeWindow来获取jQuery的引用. 先前提到的利用书签直接注入jQuery的方法在Greasemonkey不适用, 应该是 &lt;a class="reference external" href="http://wiki.greasespot.net/Sandbox"&gt;Sandbox&lt;/a&gt; 的问题.&lt;/p&gt;
&lt;p&gt;用*&amp;#64;require*有个优势时在userscript安装的时候, 回下载目标js缓存下来, 以后就不必每次都网络加载.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chrome-extensions-notes"&gt;
&lt;h2&gt;chrome extensions notes&lt;/h2&gt;
&lt;p&gt;要在chrome extensions中加载jQuery或在其他第三方实现, 可以利用其 &lt;a class="reference external" href="http://code.google.com/chrome/extensions/content_scripts.html"&gt;Content Scripts&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Content scripts are JavaScript files that run in the context of web pages.
&lt;/pre&gt;
&lt;p&gt;其实UserScript可以直接作为Chrome的扩展进行用, &lt;a class="reference external" href="http://www.chromium.org/developers/design-documents/user-scripts"&gt;官方文档&lt;/a&gt;, 但不支持*&amp;#64;require*的解析, 要自己下载并确定顺序:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
content_scripts::js, The list of JavaScript files to be injected into matching pages.
These are injected in the order they appear in this array.
&lt;/pre&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>

