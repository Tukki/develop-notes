<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://tukki.github.io/develop-notes/feed.atom</id>
  <updated>2012-04-03T00:00:00Z</updated>
  <link href="http://tukki.github.io/develop-notes/" />
  <link href="http://tukki.github.io/develop-notes/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Notes for Middleware</title>
    <id>http://tukki.github.io/develop-notes/2012/04/03/notes-for-middleware</id>
    <updated>2012-04-03T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/04/03/notes-for-middleware" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;还没认真地去看PEP333, 只是记录&lt;/p&gt;
&lt;p&gt;以前用django的时候, 没有区分好其内置的 &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/topics/http/middleware"&gt;Django Middleware&lt;/a&gt; 和标准下的 &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0333/#id17"&gt;WSGI Middleware&lt;/a&gt;. 直到离开过Django, 才明白为什么叫 &amp;quot;Django lets you write web apps in Django&amp;quot;&lt;/p&gt;
&lt;p&gt;django把wsgi隐藏的太好了. 以致我曾认为wsgi就是django这样的. environ真的很少用到.&lt;/p&gt;
&lt;p&gt;现在看来, django的middleware是对wsgi的middleware在django层面的再封装, 提供django-like的实现方式: process_request, proces_response, etc. 模仿PJE的说法 &lt;a class="reference external" href="http://dirtsimple.org/2007/02/wsgi-middleware-considered-harmful.html"&gt;If your appkication requires that API to be present, then it's not middleware any more!&lt;/a&gt;, django的middleware更多时候, 是application的一部分, 其复用程度, 局限于django工程.&lt;/p&gt;
&lt;p&gt;这里匆忙找到的两篇博文, &lt;a class="reference external" href="http://www.evanfosmark.com/2008/12/python-wsgi-middleware-for-automatic-gzipping/"&gt;Python WSGI Middleware for automatic Gzipping&lt;/a&gt; 介绍了如何写WSGI标准的Middleware; &lt;a class="reference external" href="http://eflorenzano.com/blog/2008/11/17/wsgi-middlware-awesome-django-use-it-more/"&gt;WSGI Middleware is Awesome, and Django Should Use It More&lt;/a&gt;, 介绍1.4之前如何整合django和其他Middleware实现.&lt;/p&gt;
&lt;p&gt;对于WSGI, 在django的1.4出来后更好的支持, &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/releases/1.4/#improved-wsgi-support"&gt;Improved WSGI support&lt;/a&gt;, 或者, django要回归WSGI生态圈了, 事实上, 我不确认django是否离开过&lt;/p&gt;
&lt;p&gt;&amp;lt;Tue Apr  3 22:07:13 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">Why I leave Pyramid</title>
    <id>http://tukki.github.io/develop-notes/2012/04/03/why-I-leave-pyramid</id>
    <updated>2012-04-03T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/04/03/why-I-leave-pyramid" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.pylonsproject.org/"&gt;Pyramid&lt;/a&gt;, Pylons和Repoze.bfg两个框架的合并产物. 2011年下半年用来做个两个最后失败只有上线没有运营的工程. 现在, 已经确认未来有一段时间不会再用其来构建python web project. 离开, 纯属个人喜欢, 非基于技术性的选择.&lt;/p&gt;
&lt;p&gt;一开始, 只是在享受django带来方便的同时, 不适应其居多的限制. 作为一个爱折腾喜欢灵活的人, 开始尝试 pylons + sqlalchemy. 却又适逢Pylons停止开发, 和Repoze.bfg衍生出Pyramid, 出于技术框架的在开源社区上面的支持程度来作长远的考虑 -- 回想这一点, 觉得有点不妥, startup的时候, 长远考虑不一定是件好事, 未来变化太多了, startup或者应该用熟悉的工具尽快起步 -- 于是改用了Pyramid.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Web development with style, your way!
&lt;/pre&gt;
&lt;p&gt;这句吸引了我. 但事实上, 自己对 web development 还没有自己的style. 不过, 里面一个单文件就搭建好一个简单的application, 至少当时对于只用过django的我是很吸引的. 当然django也可以做到, 其他框架也至此(web.py, flask). 借口! 灵活性吸引了我.&lt;/p&gt;
&lt;p&gt;django外面的世界, Template上面mako, jinja2都比django内置的强大(个人认为) form也更多的选择, django的orm在非django环境下面使用有点麻烦. 这些, 在Pylons/Pyramid上面都能自主选择.&lt;/p&gt;
&lt;p&gt;也许是太灵活, 而且我还是个版本控, 导致还没有style的我在选择上面走了不少弯路.&lt;/p&gt;
&lt;p&gt;1.0/1.1版的文档没有1.3版的清晰, 主推过Traversal, 事实上更多人习惯的是Route.&lt;/p&gt;
&lt;p&gt;内置的时Chameleon Template, 要用Mako还需要额外配置一下.&lt;/p&gt;
&lt;p&gt;内置的Authorization Policy, 感觉还不如用repoze.who/repoze.what. 一直就想不明白, 作为一个&amp;quot;灵活的框架&amp;quot;, 要内置的Authorization Policy干啥, 想原Pylons那样, 指导用可选的第三方实现不是一样可以吗?&lt;/p&gt;
&lt;p&gt;现在第三方依赖和第三方可选是两回事. Pyramid一开始时第三方依赖严重, 导致版本升级协调难. 在WebOb和Paste上面就载过跟斗. 后来Pyramid把Paste也舍弃了, 直接内置了相关的实现,(应该没记错). 也不知道算不算是间好事.&lt;/p&gt;
&lt;p&gt;可能, 当时最不习惯的, 莫过于interfaces了. 是Python不是Java吧.&lt;/p&gt;
&lt;p&gt;其实, 更多还是个人原因, 用一样的东西就喜欢全局地看其功能, 去了解其底层的实现. 而且自己还不是一个在深入研究python web framework的人. 所以, pyramid的灵活性, 不是我现在要去handle的. 灵活又小的框架, 现在有个想法, I will get &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; a try.&lt;/p&gt;
&lt;p&gt;不想掉入什么语言之争, 框架之争. 用合适的工具来解决问题. sorry, Pyramid. 在索取阶段已经选择离开, 还没作建设性的回馈. 有机会, 再合作.&lt;/p&gt;
&lt;p&gt;balabala又一个小时, 回看, 实在没什么建设性的内容. 总结能力要继续提高才行.&lt;/p&gt;
&lt;p&gt;&amp;lt;Tue Apr  3 16:38:33 CST 2012&amp;gt;&lt;/p&gt;
</content>
  </entry>
  <entry xml:base="http://tukki.github.io/develop-notes/feed.atom">
    <title type="text">客户端不同网站间交互实现记录</title>
    <id>http://tukki.github.io/develop-notes/2012/01/05/different-sites-communication-on-clientside</id>
    <updated>2012-01-05T00:00:00Z</updated>
    <link href="http://tukki.github.io/develop-notes/2012/01/05/different-sites-communication-on-clientside" />
    <author>
      <name>稻草人.L</name>
    </author>
    <content type="html">&lt;p&gt;起个名字真难. 没有标题说的那么大而全, 只是记录下简单自己在2011后半年遇见的几个交互实现.&lt;/p&gt;
&lt;div class="section" id="javascript"&gt;
&lt;h2&gt;JavaScript生成链接&lt;/h2&gt;
&lt;p&gt;Delicious, weibo的分享按钮.&lt;/p&gt;
&lt;p&gt;这一类是最常见的. JavaScript获取需要的信息, 构建链接, 用window.open打开新窗口.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="iframe"&gt;
&lt;h2&gt;服务器生成iframe&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://readitlaterlist.com/api/buttons"&gt;ReadItLater Button&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JavaScript生成一iframe插入当前页面, 把需要保持的信息放在iframe上src的链接参数中, 让RIL服务器根据参数值动态生成交互按钮返回作为iframe的内容. 因为使用的是iframe, RIL可以判断用户是否处于登陆状态(根据cookie), 去决定返回让用户点击的时候跳转登陆的按钮, 还是直接POST进行保存内容的按钮, 还是提示用户当前页面处于&amp;quot;已记录&amp;quot;状态. 在生成iframe的一刻已经决定了交换的内容, 尔后进行交换时互不干涉.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="javascriptiframe"&gt;
&lt;h2&gt;JavaScript生成iframe&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.instapaper.com"&gt;Instapaper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instapaper的&amp;quot;Read Later&amp;quot;按钮, 也是生成iframe. 不过iframe里面需要交换的内容, 是本地js设定的. 服务器返回了iframe的内容模板字符串, 本地js获取需要的值根据模板生成目标内容, 由本地js直接写不带src的iframe.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="html5"&gt;
&lt;h2&gt;HTML5&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://developer.mozilla.org/en/DOM/window.postMessage"&gt;HTML5 window.postMessage&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
window.postMessage is a method for safely enabling cross-origin communication.
&lt;/pre&gt;
&lt;p&gt;没实际去应用过, 这个算是HTML5提供的官方解决方案了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="flash"&gt;
&lt;h2&gt;Flash&lt;/h2&gt;
&lt;p&gt;Diigo, WebNotes提供嵌入当前页面的工具条. 没有认真拆解过, 但确认其没用到Html5特性. 而且两个都属于有后续有不确定交互发生的存在, 由于iframe设定是&amp;quot;上下文无关&amp;quot;. 那猜想应该是用了flash. &lt;a class="reference external" href="http://www.adobe.com/devnet/flash/articles/external_interface.html"&gt;Using the External API for Flash-JavaScript Communication&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;直接请求&lt;/h2&gt;
&lt;p&gt;WebNotes的工具条, 刚才用Firebug测了下, 不是Flash. (内置的flash显示时timer, 不知道时用了干啥的, 心跳包?). 对于HighLighting触发时, 是一GET请求, 带好长的一段编码/加密过的参数. 然后返回一JS, try{...}catch(e){}&lt;/p&gt;
&lt;p&gt;updated: &amp;lt;!-- Fri Jan  6 14:33:07 CST 2012 --&amp;gt;&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>

